import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:intl/intl.dart';
import '../../providers/labour_tools_provider.dart';
import '../../theme/app_colors.dart';

class LabourToolsScreen extends ConsumerStatefulWidget {
  const LabourToolsScreen({super.key});

  @override
  ConsumerState<LabourToolsScreen> createState() => _LabourToolsScreenState();
}

class _LabourToolsScreenState extends ConsumerState<LabourToolsScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  MobileScannerController? _scannerController;
  bool _isScanning = false;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _scannerController?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Tools'),
        bottom: TabBar(
          controller: _tabController,
          tabs: [
            const Tab(icon: Icon(Icons.qr_code_scanner), text: 'Scan QR'),
            const Tab(icon: Icon(Icons.inventory_2), text: 'My Tools'),
            const Tab(icon: Icon(Icons.history), text: 'History'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildQRScannerTab(),
          _buildMyToolsTab(),
          _buildHistoryTab(),
        ],
      ),
    );
  }

  Widget _buildQRScannerTab() {
    return Column(
      children: [
        Expanded(
          child: _isScanning
              ? _buildScannerView()
              : _buildScannerPlaceholder(),
        ),
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              if (!_isScanning)
                ElevatedButton.icon(
                  onPressed: _startScanning,
                  icon: const Icon(Icons.qr_code_scanner),
                  label: const Text('Scan QR Code'),
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 56),
                    backgroundColor: AppColors.primary,
                    foregroundColor: Colors.white,
                  ),
                )
              else
                ElevatedButton.icon(
                  onPressed: _stopScanning,
                  icon: const Icon(Icons.stop),
                  label: const Text('Stop Scanning'),
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 56),
                    backgroundColor: Colors.red,
                    foregroundColor: Colors.white,
                  ),
                ),
              const SizedBox(height: 12),
              Text(
                'Scan the QR code generated by the engineer to issue or return tools',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Colors.grey[600],
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildScannerPlaceholder() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.qr_code_scanner,
            size: 120,
            color: Colors.grey[300],
          ),
          const SizedBox(height: 24),
              Text(
                'Tap to scan QR code',
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Point camera at QR code to issue or return tools',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Colors.grey[500],
                ),
                textAlign: TextAlign.center,
              ),
        ],
      ),
    );
  }

  Widget _buildScannerView() {
    if (_scannerController == null) {
      return _buildScannerPlaceholder();
    }
    
    return Stack(
      children: [
        MobileScanner(
          controller: _scannerController!,
          onDetect: _onQRDetected,
        ),
        // Overlay with scanning area
        CustomPaint(
          painter: _ScannerOverlayPainter(),
          child: Container(),
        ),
        // Instructions
        Positioned(
          bottom: 100,
          left: 0,
          right: 0,
          child: Container(
            padding: const EdgeInsets.all(16),
            margin: const EdgeInsets.symmetric(horizontal: 32),
            decoration: BoxDecoration(
              color: Colors.black.withValues(alpha: 0.7),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(
              'Align QR code in the frame',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      ],
    );
  }

  void _startScanning() {
    setState(() {
      _scannerController = MobileScannerController(
        detectionSpeed: DetectionSpeed.noDuplicates,
        facing: CameraFacing.back,
      );
      _isScanning = true;
    });
  }

  void _stopScanning() {
    setState(() {
      _scannerController?.dispose();
      _scannerController = null;
      _isScanning = false;
    });
  }

  void _onQRDetected(BarcodeCapture capture) {
    if (capture.barcodes.isEmpty) return;
    
    final barcode = capture.barcodes.first;
    if (barcode.rawValue == null) return;
    
    final qrToken = barcode.rawValue!;
    _stopScanning();
    _processQRScan(qrToken);
  }

  Future<void> _processQRScan(String qrToken) async {
    // Show loading
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    try {
      final result = await ref.read(scanToolQRProvider(qrToken).future);
      
      if (!context.mounted) return;
      Navigator.pop(context); // Close loading

      final action = result['action'] as String;
      final tool = result['tool'] as Map<String, dynamic>;
      final message = result['message'] as String;

      // Show success dialog
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(action == 'ISSUED' ? 'Tool Issued' : 'Tool Returned'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('${tool['name']} (${tool['tool_code']})'),
              const SizedBox(height: 8),
              Text(message, style: Theme.of(context).textTheme.bodySmall),
            ],
          ),
          actions: [
            ElevatedButton(
              onPressed: () {
                Navigator.pop(context);
                ref.invalidate(myIssuedToolsProvider);
                ref.invalidate(myToolHistoryProvider);
              },
              child: const Text('OK'),
            ),
          ],
        ),
      );
    } catch (e) {
      if (!context.mounted) return;
      Navigator.pop(context); // Close loading

      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Error'),
          content: Text(e.toString().replaceAll('Exception: ', '')),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('OK'),
            ),
          ],
        ),
      );
    }
  }

  Widget _buildMyToolsTab() {
    final toolsAsync = ref.watch(myIssuedToolsProvider);
    
    return toolsAsync.when(
      data: (tools) {
        if (tools.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.inventory_2_outlined, size: 64, color: Colors.grey[400]),
                const SizedBox(height: 16),
                  Text(
                    'No tools issued',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Colors.grey[600],
                  ),
                ),
              ],
            ),
          );
        }

        return RefreshIndicator(
          onRefresh: () async => ref.refresh(myIssuedToolsProvider.future),
          child: ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: tools.length,
            itemBuilder: (context, index) {
              final tool = tools[index];
              return _buildToolCard(tool);
            },
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, _) => Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: Colors.red[300]),
            const SizedBox(height: 16),
            const Text('Error', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text(err.toString(), textAlign: TextAlign.center),
          ],
        ),
      ),
    );
  }

  Widget _buildToolCard(Map<String, dynamic> tool) {
    final theme = Theme.of(context);
    final issuedAt = DateTime.parse(tool['issued_at']);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: ListTile(
        leading: Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: Colors.orange.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(8),
          ),
          child: const Icon(Icons.construction, color: Colors.orange),
        ),
        title: Text(
          tool['tool_name'] ?? 'Unknown Tool',
          style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(tool['tool_code'] ?? '', style: theme.textTheme.bodySmall),
            const SizedBox(height: 4),
            Text(
              'Issued: ${DateFormat('MMM dd, yyyy hh:mm a').format(issuedAt)}',
              style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
            ),
            if (tool['project_name'] != null)
              Text(
                tool['project_name'],
                style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[500]),
              ),
          ],
        ),
        trailing: Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: Colors.orange.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(4),
          ),
          child:             Text(
              'Issued',
            style: TextStyle(
              color: Colors.orange,
              fontSize: 12,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildHistoryTab() {
    final historyAsync = ref.watch(myToolHistoryProvider({'projectId': null, 'status': null}));
    
    return historyAsync.when(
      data: (transactions) {
        if (transactions.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.history, size: 64, color: Colors.grey[400]),
                const SizedBox(height: 16),
                  Text(
                    'No tool history',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Colors.grey[600],
                  ),
                ),
              ],
            ),
          );
        }

        return RefreshIndicator(
          onRefresh: () async => ref.refresh(myToolHistoryProvider({'projectId': null, 'status': null}).future),
          child: ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: transactions.length,
            itemBuilder: (context, index) {
              final tx = transactions[index];
              return _buildHistoryCard(tx);
            },
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, _) => Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: Colors.red[300]),
            const SizedBox(height: 16),
            const Text('Error', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text(err.toString(), textAlign: TextAlign.center),
          ],
        ),
      ),
    );
  }

  Widget _buildHistoryCard(Map<String, dynamic> tx) {
    final theme = Theme.of(context);
    final isReturned = tx['returned_at'] != null;
    final issuedAt = DateTime.parse(tx['issued_at']);
    final returnedAt = tx['returned_at'] != null ? DateTime.parse(tx['returned_at']) : null;

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        tx['tool_name'] ?? 'Unknown Tool',
                        style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                      ),
                      Text(
                        tx['tool_code'] ?? '',
                        style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: isReturned ? Colors.green.withValues(alpha: 0.1) : Colors.orange.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    isReturned ? 'Returned' : 'Issued',
                    style: TextStyle(
                      color: isReturned ? Colors.green : Colors.orange,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text('Issued', style: TextStyle(color: Colors.grey)),
                      Text(
                        DateFormat('MMM dd, yyyy').format(issuedAt),
                        style: theme.textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w500),
                      ),
                      Text(
                        DateFormat('hh:mm a').format(issuedAt),
                        style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ),
                if (isReturned && returnedAt != null) ...[
                  const Icon(Icons.arrow_forward, color: Colors.grey),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Returned', style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600])),
                        Text(
                          DateFormat('MMM dd, yyyy').format(returnedAt),
                          style: theme.textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w500),
                        ),
                        Text(
                          DateFormat('hh:mm a').format(returnedAt),
                          style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
                        ),
                      ],
                    ),
                  ),
                ],
              ],
            ),
            if (tx['project_name'] != null) ...[
              const SizedBox(height: 8),
              Text(
                tx['project_name'],
                style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[500]),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

// Custom painter for scanner overlay
class _ScannerOverlayPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.transparent
      ..style = PaintingStyle.fill;

    final path = Path()
      ..addRect(Rect.fromLTWH(0, 0, size.width, size.height));

    final scanAreaSize = size.width * 0.7;
    final scanArea = Rect.fromCenter(
      center: Offset(size.width / 2, size.height / 2),
      width: scanAreaSize,
      height: scanAreaSize,
    );

    final scanAreaPath = Path()
      ..addRect(scanArea);

    final cutoutPath = Path.combine(
      PathOperation.difference,
      path,
      scanAreaPath,
    );

    canvas.drawPath(cutoutPath, paint);

    // Draw border around scan area
    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3;

    canvas.drawRect(scanArea, borderPaint);

    // Draw corner indicators
    final cornerLength = 20.0;
    final cornerPaint = Paint()
      ..color = AppColors.primary
      ..style = PaintingStyle.stroke
      ..strokeWidth = 4;

    // Top-left
    canvas.drawLine(scanArea.topLeft, scanArea.topLeft + Offset(cornerLength, 0), cornerPaint);
    canvas.drawLine(scanArea.topLeft, scanArea.topLeft + Offset(0, cornerLength), cornerPaint);

    // Top-right
    canvas.drawLine(scanArea.topRight, scanArea.topRight + Offset(-cornerLength, 0), cornerPaint);
    canvas.drawLine(scanArea.topRight, scanArea.topRight + Offset(0, cornerLength), cornerPaint);

    // Bottom-left
    canvas.drawLine(scanArea.bottomLeft, scanArea.bottomLeft + Offset(cornerLength, 0), cornerPaint);
    canvas.drawLine(scanArea.bottomLeft, scanArea.bottomLeft + Offset(0, -cornerLength), cornerPaint);

    // Bottom-right
    canvas.drawLine(scanArea.bottomRight, scanArea.bottomRight + Offset(-cornerLength, 0), cornerPaint);
    canvas.drawLine(scanArea.bottomRight, scanArea.bottomRight + Offset(0, -cornerLength), cornerPaint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}
